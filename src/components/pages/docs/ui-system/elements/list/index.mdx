---
title: Elements / List
---

# List

List is a basic component to render simple lists. It could help you
avoiding repeatable patterns and using **map** function repeatedly.

Secondly, it migh help you keeping components more structured and
organized.

## Example

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const component = ({ name, surname }) => (
  <Element block label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List
    rootElement
    block
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={component}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Render Items

There are several ways of rendering children within **List** component.
So let's take a look at them.

### Render children

First of all, you can use **List** as a wrapper for
your components and just pass children normally like you do in React.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List rootElement vertical>
    <User name="John" surname="Doe" />
    <User name="Sam" surname="Johnson" />
  </List>
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

### Render from an array

Another way of rendering children is passing a props **data** and **component**
to List component and it will iterate on the background and render list
of elements.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { key: '1', name: 'John', surname: 'Doe' },
  { key: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => <List rootElement vertical data={data} component={User} />

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Data properties

Prop **data** must be of **Array** type, but the items within array can
be of different types.

### Array of objects

Probably the most common case is to render array of objects as a list.
This can be simply done by following example:

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

// using key is not required, List fallbacks to map index value
const data = [
  { key: '1', name: 'John', surname: 'Doe' },
  { key: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => <List rootElement vertical data={data} component={User} />

// ↓↓↓ List ↓↓↓
render(<Users />)
```

### Array of strings or numbers

Sometimes you just want to render list of items which accepts only one
prop of type **string** or **number**. In that case you can just
simply pass array of values as **data** prop. It also filters **null**
and **undefined** values, therefore doesn't render empty elements
which could lead to throwing errors.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = ['John Doe', 'Sam Johnson']

const User = ({ label }) => <Element label={label} css={styles} />

const Users = () => (
  <List
    rootElement
    vertical
    // each item will be passed as 'label' prop
    valueName="label"
    data={data}
    component={User}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

As there is always need to add a **key** when rendering elements
dynamically, you don't have to worry about it. It will add
a [key](https://reactjs.org/docs/lists-and-keys.html) for you out
of the box.

## Item key value

By default, it will look for **key** &rarr; **id** &rarr; **itemId** in
your item object within **data** prop. In case there is no value from
those mentioned previously, it will fallback to **index** value from map
function.

Item key value can be customizable as well. You can pass **itemKey**
prop which can be either type of **string** or a **function**.

When passing a string value, **List** will use it as a key name from
item object.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { userId: '1', name: 'John', surname: 'Doe' },
  { userId: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List rootElement vertical itemKey="userId" data={data} component={User} />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

By passing a function value you can create a customized **key** for each
element.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { userId: '1', name: 'John', surname: 'Doe' },
  { userId: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List
    rootElement
    vertical
    contentAlignX="block"
    itemKey={(itemProps, i) => itemProps.userId}
    data={data}
    component={User}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Custom item component

In that case, you want to render items but some of them need to be
render using different component, you may just want to add a
**component** prop into you object data item.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const SpecialUser = ({ name, surname }) => (
  <Element label={name + ' ' + surname + ' - Special user'} css={styles} />
)

const data = [
  { userId: '1', name: 'John', surname: 'Doe' },
  // ↓↓↓ added component property
  { userId: '2', name: 'Sam', surname: 'Johnson', component: SpecialUser },
]

const Users = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    itemKey={(itemProps) => itemProps.userId}
    data={data}
    component={User}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Custom item props

You can even **data** create dynamically by using **itemProps** prop.
This prop can be either an object or a callback function which receives
item props.

When using a callback function, you get the following arguments: (
**item**: item props from data array, **extendProps**: [object](#extend-props)
of boolean values (**index**, **position**, **first**, **last**, **odd**, **even**)
and expected to return an object.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const User = ({ userId, name, surname }) => (
  <Element
    label={'[ ' + userId + ' ] - ' + name + ' ' + surname}
    css={styles}
  />
)

const Users = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    itemProps={(item, extendProps) => ({
      // ↓↓↓ create your own props dynamically
      userId: extendProps.position, // + '-' + extendProps.position
    })}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Extend props

Another example of extending Item component props. You can, for example,
pass all **extendProps** values and handle your component styles according
to it.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname, position, odd }) => (
  <Element
    label={'[ ' + position + ' ] - ' + name + ' ' + surname}
    css={styles}
    style={{
      color: odd ? 'palevioletred' : 'papayawhip',
      background: odd ? 'papayawhip' : 'palevioletred',
    }}
  />
)

const Users = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    itemProps={(item, extendProps) => extendProps}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Wrapping items

If you would like to render a list of items but need to wrap each
element by another component, then, there is no need to create a new
component where you combine them together. You can just use
**wrapComponent** prop to add a wrapping component. For example, this
might be useful when you have a list of links but want to wrap them to
**li** HTML tag to create a HTML valid list of links.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const Wrapper = (props) => <li {...props} />

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List
    rootElement
    tag="ul"
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    wrapComponent={Wrapper}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Extend Wrapper props

Another example of extending Item component props. You can, for example,
pass all **extendProps** values and handle your component styles according
to it.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const Wrapper = ({ position, children }) => (
  <Element tag="li" css={styles}>
    [{position}] {children}
  </Element>
)

const User = ({ name, surname }) => <Element label={name + ' ' + surname} />

const Users = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    wrapComponent={Wrapper}
    wrapProps={(item, extendProps) => extendProps}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## List properties

List accepts all [Element properties](/docs/ui-system/elements/element)
(except `label` and `content`) and the following props.

| Name          | Type                       | Default value | Description                                                                                           |
| ------------- | -------------------------- | :-----------: | :---------------------------------------------------------------------------------------------------- |
| rootElement   | **boolean**                |     false     | Whether a root element should be rendered or the output should be just a type of React **Fragment**   |
| children      | **ReactNode**              |               | Children to List can be passed manually by using **children** prop.                                   |
| data          | **Array**                  |               | An array of item values to be passed to item component                                                |
| component     | **ComponentType**          |               | A component to be rendered per item                                                                   |
| wrapComponent | **ComponentType**          |               | A component to be used as a wrapper component for item component                                      |
| valueName     |                            |               | Can be used when **data** consists of **strings** or **numbers** to name value being passed as a prop |
| itemKey       | **string** \| **callback** |               | Prop for defining item key name / value if default behavior doesn't work out                          |
| itemProps     | **object** \| **callback** |               | A custobizable hook for dynamically render props for each item                                        |
| wrapProps     | **object** \| **callback** |               | A custobizable hook for dynamically render props for each item                                        |
