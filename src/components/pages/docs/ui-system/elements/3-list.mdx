---
title: Elements / List
---

# List

List is a component to render simple lists with extensive API.

It also helps avoiding repeatable patterns and using array `map`
function repeatedly. List component helps keeping components
more structured and organized.

List provides extensive API, like ability to wrap your `component`
by `wrapComponent` and possibility of extending `itemProps` and
`wrapProps` accordingly for better component composition.

## Example

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const component = ({ name, surname }) => (
  <Element block label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List
    rootElement
    block
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={component}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Root element

By default the List component renders [Fragment](https://reactjs.org/docs/fragments.html)
of items. To enable [Element](/docs/ui-system/elements/element)
component to be used as **root** element, `rootElement` prop needs
to be set as `true`.

Using the root element provides another extensive oportunities
for component composition, e.g. vertical/horizontal alignment, attaching
`beforeContent` or `afterContent` etc.

**Warning:** `content` and `label` props are being ignored.

## Render Items

There are several ways of rendering children within **List** component.

### Render children

First of all, you can use **List** as a wrapper for
your components and just pass children normally like you do in React.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const User = ({ name, surname }) => (
  <Element label={name + ' ' + surname} css={styles} />
)

const Users = () => (
  <List rootElement vertical>
    <User name="John" surname="Doe" />
    <User name="Sam" surname="Johnson" />
  </List>
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

### Render from an array

Another way of rendering children is passing a props `data` and `component`
to the List component. It will iterate over the `data` array and pass item
props to the assigned `component`.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

// key is not passed, it's used as a React key prop
const data = [
  { key: '1', name: 'John', surname: 'Doe' },
  { key: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={`${name} ${surname}`} css={styles} />
)

const UserList = () => <List rootElement data={data} component={User} />

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

## Data properties

Prop `data` must be of `Array` type, but the items within array can
be of different types. Let's dive more into detail in the following
sections.

### Array of objects

One of the most common cases is to render `array` of `objects` as a list.
This can be simply done by following example:

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

// using key is not required, List fallbacks to map index value
const data = [
  { key: '1', name: 'John', surname: 'Doe' },
  { key: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={`${name} ${surname}`} css={styles} />
)

const UserList = () => <List rootElement data={data} component={User} />

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

### Array of strings or numbers

Sometimes the case is just to render list of items which accepts only one
prop of type `string` or `number`. In that case can be simply passed
an array of `string[]` or `number[]` as `data` prop. In this case must be
defined also **valueName** prop which defines name of the prop to be passed
to the iteration component.

List also filters `null` and `undefined` values out of the box, therefore
doesn't render empty elements which could lead to throwing errors.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = ['John Doe', 'Sam Johnson']

const User = ({ label }) => <Element label={label} css={styles} />

const Users = () => (
  <List
    rootElement
    vertical
    // each item will be passed as 'label' prop
    valueName="label"
    data={data}
    component={User}
  />
)

// ↓↓↓ List ↓↓↓
render(<Users />)
```

## Item key value

There is always a need to add a **key** when [rendering elements
dynamically](https://reactjs.org/docs/lists-and-keys.html).

By default, List component will look for **key** &rarr; **id** &rarr;
**itemId** in your item `object` within `data` prop. In the case, there is
non of the mentioned params available, List will fallback to **index**
value from the array `map` function.

List also provides control over items keys. To define custom `key`,
the **itemKey** prop can be passed either as a type of `string`
or a callback `function`.

### itemKey as a string

When passing a `string` value, **List** will use it as a `key` name from
item object from `data` array. See the example below.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { userId: '1', name: 'John', surname: 'Doe' },
  { userId: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={`${name} ${surname}`} css={styles} />
)

const UserList = () => (
  <List rootElement itemKey="userId" data={data} component={User} />
)

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

### itemKey as a callback

By passing a callback function as value can be created a customized **key**
for each element. See the example below.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

// userId as a key
const data = [
  { userId: '1', name: 'John', surname: 'Doe' },
  { userId: '2', name: 'Sam', surname: 'Johnson' },
]

const User = ({ name, surname }) => (
  <Element label={`${name} ${surname}`} css={styles} />
)

const UserList = () => (
  <List
    rootElement
    vertical
    contentAlignX="block"
    itemKey={(itemProps, i) => itemProps.userId}
    data={data}
    component={User}
  />
)

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

## Custom item component

In that case, you want to render items but some of them need to be
render using different component, you may just want to add a
**component** prop into you object data item.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const User = ({ name, surname }) => (
  <Element label={`${name} ${surname}`} css={styles} />
)

const SpecialUser = ({ name, surname }) => (
  <Element label={`${name} ${surname} - Special user`} css={styles} />
)

const data = [
  { userId: '1', name: 'John', surname: 'Doe' },
  // ↓↓↓ added component property
  { userId: '2', name: 'Sam', surname: 'Johnson', component: SpecialUser },
]

const UserList = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    itemKey={(itemProps) => itemProps.userId}
    data={data}
    component={User}
  />
)

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

## Custom Item props

You can even **data** create dynamically by using `itemProps` prop.
This prop can be either an object or a callback function.

When using a callback function, the function accepts the following arguments:
`(item, extendProps) => ({ /* returned object */ })`.

Where `item` is data from `data` array prop and `extendProps` are
meta data of each item in the list containing (**index**, **position**,
**first**, **last**, **odd**, **even**).

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const User = ({ userId, name, surname }) => (
  <Element label={`[${userId}] - ${name} ${surname}`} css={styles} />
)

const UserList = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    itemProps={(item, extendProps) => ({
      // ↓↓↓ create your own props dynamically
      userId: extendProps.position,
    })}
  />
)

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

## Wrapping items by another component

To render a list of items but need to wrap each element by
another component, there is no need to first create a new React
component to combine them together. Prop `wrapComponent` is a way
to go to add a wrapping component.

This might be useful in situations like having a list of links but
want to wrap them to `li` HTML tag to create a HTML valid list of links.

The **root** element of List is [Element component](/docs/ui-system/elements/element),
therefore can cover rendering `ul` HTML tag to have a full valid
and extensible HTML list.

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const Wrapper = (props) => <li {...props} />

const User = ({ name, surname }) => (
  <Element label={`${name} ${surname}`} css={styles} />
)

const UserList = () => (
  <List
    rootElement
    tag="ul"
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    wrapComponent={Wrapper}
  />
)

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

## Extend Wrapper props

Extending wrapper props works the same way as extending item props.

When using a callback function, the function accepts the following arguments:
`(item, extendProps) => ({ /* returned object */ })`.

Where `item` is data from `data` array prop and `extendProps` are
meta data of each item in the list containing (**index**, **position**,
**first**, **last**, **odd**, **even**).

```tsx
// import { Element, List } from '@vitus-labs/elements'

const styles = (css) => css`
  ${defaultCss};
  padding: 8px;
  margin: 4px;
`

const data = [
  { name: 'John', surname: 'Doe' },
  { name: 'Sam', surname: 'Johnson' },
]

const Wrapper = ({ position, children }) => (
  <Element tag="li" css={styles}>
    [{position}] {children}
  </Element>
)

const User = ({ name, surname }) => <Element label={name + ' ' + surname} />

const UserList = () => (
  <List
    rootElement
    contentDirection="rows"
    contentAlignX="block"
    data={data}
    component={User}
    wrapComponent={Wrapper}
    wrapProps={(item, extendProps) => extendProps}
  />
)

// ↓↓↓ List ↓↓↓
render(<UserList />)
```

## List properties

List accepts all [Element](/docs/ui-system/elements/element) properties
(except `label` and `content`) and the following props. These props
are taken into account only when `rootElement` is **enabled**.

| Name          | Type                    | Default value | Description                                                                                           |
| ------------- | ----------------------- | :-----------: | :---------------------------------------------------------------------------------------------------- |
| rootElement   | **boolean**             |     false     | Whether a root element should be rendered or the output should be just a type of React **Fragment**   |
| children      | **ReactNode**           |               | Children to List can be passed manually by using **children** prop                                    |
| data          | **Array**               |               | An array of item values to be passed to item component                                                |
| component     | **ComponentType**       |               | A component to be rendered per item                                                                   |
| wrapComponent | **ComponentType**       |               | A component to be used as a wrapper component for item component                                      |
| valueName     | **string**              |               | Can be used when **data** consists of **strings** or **numbers** to name value being passed as a prop |
| itemKey       | **string** **callback** |               | Prop for defining item key name / value if default behavior doesn't work out                          |
| itemProps     | **object** **callback** |               | A custobizable hook for dynamically render props for each item                                        |
| wrapProps     | **object** **callback** |               | A custobizable hook for dynamically render props for each item                                        |
